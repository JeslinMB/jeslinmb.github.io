# -*- coding: utf-8 -*-
"""Cleanliness detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Tko78jBXO9kknbL5P9uqCDGmHHx4uX7G
"""

#required configurations
API_KEY = "4c7cbde2-eeb6-4dbf-b73b-7f1dfc38f717"
DEVICE_ID = "BOLT5914166"
telegram_chat_id = "@temperature_alert_devp123"
telegram_bot_id = "bot6477955203:AAH_sse7jZGXGsW5SqG6GcbFidFftlH3lkc"

!pip install boltiot
from boltiot import Sms, Bolt

mybolt=Bolt(API_KEY,DEVICE_ID)

# Commented out IPython magic to ensure Python compatibility.
#displaying the timetaken for each cell to execute
!pip install ipython-autotime
# %load_ext autotime

!pip install bing-image-downloader   #helps to collect your dataset from bing

!mkdir cityimages

from bing_image_downloader import downloader
downloader.download("pollution and smoke filled city places",limit=25,output_dir='cityimages',
                    adult_filter_off=True)

downloader.download("Beautiful Green Places",limit=25,output_dir='cityimages',
                    adult_filter_off=True)

#Preprocessing

import os                         # to access the various folders
import matplotlib.pyplot as plt   # to display the images when needed
import numpy as np                # numerical computations
from skimage.io import imread     # to read the images
from skimage.transform import resize  # all images need to be in a uniform size for classification

target=[]
images=[]
flat_data=[]

DATADIR = '/content/cityimages'
CATEGORIES=['pollution and smoke filled city places','Beautiful Green Places']

for category in CATEGORIES:
  class_num = CATEGORIES.index(category)
  path = os.path.join(DATADIR,category)
  for img in os.listdir(path):
    img_array = imread(os.path.join(path,img))
    #print(img_array.shape)
    #plt.imshow(img_array)
    img_resized = resize(img_array,(150,150,3))
    flat_data.append(img_resized.flatten())
    images.append(img_resized)
    target.append(class_num)

flat_data=np.array(flat_data)
target=np.array(target)
images=np.array(images)

len(flat_data[0])

target

unique,count=np.unique(target,return_counts=True)
plt.bar(CATEGORIES,count)

#Split data into training & testing
from sklearn.model_selection import train_test_split
x_train,x_test,y_train,y_test=train_test_split(flat_data,target,test_size=0.3,
                                               random_state=109)

from sklearn.model_selection import GridSearchCV
from sklearn import svm
param_grid=[
    {'C':[1,10,100,1000],'kernel':['linear']},
    {'C':[1,10,100,1000],'gamma':[0.001,0.0001],'kernel':['rbf']}
 ]

svc = svm.SVC(probability=True)
clf = GridSearchCV(svc,param_grid)
clf.fit(x_train,y_train)

y_pred = clf.predict(x_test)
y_pred

y_test

from sklearn.metrics import accuracy_score,confusion_matrix

accuracy_score(y_pred,y_test)

confusion_matrix(y_pred,y_test)

#Save the model using Pickle library
import pickle
pickle.dump(clf,open('img_model.p','wb'))

model = pickle.load(open('img_model.p','rb'))

import requests
import json
import time

def send_telegram_message(message):
    """Sends message via Telegram"""
    url = "https://api.telegram.org/" + telegram_bot_id + "/sendMessage"
    data = {
        "chat_id": telegram_chat_id,
        "text": message
    }
    try:
        response = requests.request(
            "POST",
            url,
            params=data
        )
        print("This is the Telegram URL")
        print(url)
        print("This is the Telegram response")
        print(response.text)
        telegram_data = json.loads(response.text)
        return telegram_data["ok"]
    except Exception as e:
        print("An error occurred in sending the alert message via Telegram")
        print(e)
        return False

#Testing a random image
flat_data = []
url = input('Enter your URL')
img = imread(url)
img_resized = resize(img,(150,150,3))
flat_data.append(img_resized.flatten())
flat_data = np.array(flat_data)
print(img.shape)
plt.imshow(img_resized)
y_out = model.predict(flat_data)
y_out = CATEGORIES[y_out[0]]
result = (f'{y_out}')
print(f'PREDICTED OUTPUT: {y_out}')

if result=='pollution and smoke filled city places':
    buzzer=mybolt.analogWrite('0','6')
    print(buzzer)
    time.sleep(10)
    mybolt.analogWrite('0','0')
    telegram_status = send_telegram_message("Not a safe residential area")
    print("This is the Telegram status:", telegram_status)
    time.sleep(20)

else:
    telegram_status = send_telegram_message("It's a safe residential area")
    print("This is the Telegram status:", telegram_status)
    time.sleep(20)









